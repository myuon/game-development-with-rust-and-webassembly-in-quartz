import websys;

struct Color {
    r: i32,
    g: i32,
    b: i32,
}

fun draw_triangle(
    context: JsRef,
    points: vec[struct {
        x: i32,
        y: i32,
    }],
    color: Color,
) {
    js_context_set_fill_style(
        context,
        "rgb({}, {}, {})".format(color.r.to_string(), color.g.to_string(), color.b.to_string()),
    );
    let top = points.at(0);
    let left = points.at(1);
    let right = points.at(2);
    js_context_move_to(context, top.x, top.y);
    js_context_begin_path(context);
    js_context_line_to(context, left.x, left.y);
    js_context_line_to(context, right.x, right.y);
    js_context_line_to(context, top.x, top.y);
    js_context_close_path(context);
    js_context_stroke(context);
    js_context_fill(context);
}

fun midpoint(
    point1: struct {
        x: i32,
        y: i32,
    },
    point2: struct {
        x: i32,
        y: i32,
    },
): struct {
    x: i32,
    y: i32,
} {
    return struct {
        x: (point1.x + point2.x) / 2,
        y: (point1.y + point2.y) / 2,
    };
}

fun sierpinski(
    context: JsRef,
    points: vec[struct {
        x: i32,
        y: i32,
    }],
    color: Color,
    depth: i32,
) {
    draw_triangle(context, points, color);

    let top = points.at(0);
    let left = points.at(1);
    let right = points.at(2);

    let depth_new = depth - 1;
    if depth_new > 0 {
        let next_color = Color {
            r: js_math_random_minmax(0, 255),
            g: js_math_random_minmax(0, 255),
            b: js_math_random_minmax(0, 255),
        };

        let left_middle = midpoint(top, left);
        let right_middle = midpoint(top, right);
        let bottom_middle = midpoint(left, right);
        sierpinski(
            context,
            make[vec[struct {
                x: i32,
                y: i32,
            }]](top, left_middle, right_middle),
            next_color,
            depth_new,
        );
        sierpinski(
            context,
            make[vec[struct {
                x: i32,
                y: i32,
            }]](left_middle, left, bottom_middle),
            next_color,
            depth_new,
        );
        sierpinski(
            context,
            make[vec[struct {
                x: i32,
                y: i32,
            }]](right_middle, bottom_middle, right),
            next_color,
            depth_new,
        );
    }
}

fun main() {
    js_console_log("Hello, Wasm!");

    let window = js_window();
    let document = js_window_document(window);
    let canvas = js_document_get_element_by_id(document, "canvas");
    let context = js_canvas_get_context(canvas, "2d");

    sierpinski(
        context,
        make[vec[struct {
            x: i32,
            y: i32,
        }]](
            struct {
                x: 300,
                y: 0,
            },
            struct {
                x: 0,
                y: 600,
            },
            struct {
                x: 600,
                y: 600,
            },
        ),
        Color {
            r: 0,
            g: 255,
            b: 0,
        },
        5,
    );

    let image = js_image_new();
    js_image_set_src(image, "assets/Idle (1).png");
    js_image_set_onload_ref1(image, "image_onload_callback", context);
    js_image_set_onerror(image, "image_onerror_callback");

    fetch_json("assets/rhb.json", "rhb_json_fetch_onsuccess");

    // return context;
    return nil;
}

@[ffi_export("image_onload_callback")]
fun image_onload_callback(context: i32, image: i32) {
    js_context_draw_image(JsRef::new(context), JsRef::new(image), 0, 0);
}

@[ffi_export("image_onerror_callback")]
fun image_onerror_callback(image: JsRef) {
    panic("Image failed to load");
}

fun fetch_json(path: string, callback: string) {
    js_fetch(path, callback);
}

@[ffi_export("rhb_json_fetch_onsuccess")]
fun rhb_json_fetch_onsuccess(resp_id: i32) {
    println("fetched");
}

