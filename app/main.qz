import websys;
import json;

struct Color {
    r: i32,
    g: i32,
    b: i32,
}

fun draw_triangle(
    context: JsRef,
    points: vec[struct {
        x: i32,
        y: i32,
    }],
    color: Color,
) {
    js_context_set_fill_style(
        context,
        "rgb({}, {}, {})".format(color.r.to_string(), color.g.to_string(), color.b.to_string()),
    );
    let top = points.at(0);
    let left = points.at(1);
    let right = points.at(2);
    js_context_move_to(context, top.x, top.y);
    js_context_begin_path(context);
    js_context_line_to(context, left.x, left.y);
    js_context_line_to(context, right.x, right.y);
    js_context_line_to(context, top.x, top.y);
    js_context_close_path(context);
    js_context_stroke(context);
    js_context_fill(context);
}

fun midpoint(
    point1: struct {
        x: i32,
        y: i32,
    },
    point2: struct {
        x: i32,
        y: i32,
    },
): struct {
    x: i32,
    y: i32,
} {
    return struct {
        x: (point1.x + point2.x) / 2,
        y: (point1.y + point2.y) / 2,
    };
}

fun sierpinski(
    context: JsRef,
    points: vec[struct {
        x: i32,
        y: i32,
    }],
    color: Color,
    depth: i32,
) {
    draw_triangle(context, points, color);

    let top = points.at(0);
    let left = points.at(1);
    let right = points.at(2);

    let depth_new = depth - 1;
    if depth_new > 0 {
        let next_color = Color {
            r: js_math_random_minmax(0, 255),
            g: js_math_random_minmax(0, 255),
            b: js_math_random_minmax(0, 255),
        };

        let left_middle = midpoint(top, left);
        let right_middle = midpoint(top, right);
        let bottom_middle = midpoint(left, right);
        sierpinski(
            context,
            make[vec[struct {
                x: i32,
                y: i32,
            }]](top, left_middle, right_middle),
            next_color,
            depth_new,
        );
        sierpinski(
            context,
            make[vec[struct {
                x: i32,
                y: i32,
            }]](left_middle, left, bottom_middle),
            next_color,
            depth_new,
        );
        sierpinski(
            context,
            make[vec[struct {
                x: i32,
                y: i32,
            }]](right_middle, bottom_middle, right),
            next_color,
            depth_new,
        );
    }
}

fun main() {
    js_console_log("Hello, Wasm!");

    let window = js_window();
    let document = js_window_document(window);
    let canvas = js_document_get_element_by_id(document, "canvas");
    let context = js_canvas_get_context(canvas, "2d");

    sierpinski(
        context,
        make[vec[struct {
            x: i32,
            y: i32,
        }]](
            struct {
                x: 300,
                y: 0,
            },
            struct {
                x: 0,
                y: 600,
            },
            struct {
                x: 600,
                y: 600,
            },
        ),
        Color {
            r: 0,
            g: 255,
            b: 0,
        },
        5,
    );

    let image = js_image_new();
    js_image_set_src(image, "assets/Idle (1).png");
    js_image_set_onload_ref1(image, "image_onload_callback", context);
    js_image_set_onerror(image, "image_onerror_callback");

    fetch_json("assets/rhb.json", "rhb_json_fetch_onsuccess");

    // return context;
    return nil;
}

@[ffi_export("image_onload_callback")]
fun image_onload_callback(context: i32, image: i32) {
    js_context_draw_image(JsRef::new(context), JsRef::new(image), 0, 0);
}

@[ffi_export("image_onerror_callback")]
fun image_onerror_callback(image: i32) {
    panic("Image failed to load");
}

fun fetch_json(path: string, callback: string) {
    js_fetch(path, callback);
}

@[ffi_export("rhb_json_fetch_onsuccess")]
fun rhb_json_fetch_onsuccess(resp_id: i32) {
    let ref = JsRef::new(resp_id);
    let text = jsstring(ref);

    let j or err = Json::from_string(text);
    if err != nil {
        panic("Failed to parse JSON: {}", derive::to_string(err));
    }

    let sheet = Sheet::from_json(j!);

    let image = js_image_new();
    js_image_set_src(image, "assets/Idle (1).png");
    // js_image_set_onload_ref1(image, "draw_rhb", context);
    js_image_set_onerror_closure(
        image,
        fun () {
            panic("Image failed to load");
        },
    );
}

@[ffi_export("draw_rhb")]
fun draw_rhb(context: i32, image: i32) {
    //
}

struct Sheet {
    frames: map[string, Cell],
}

module Sheet {
    fun from_json(j: Json): Sheet {
        if j.t_object == nil {
            panic("Expected object, got {}", derive::to_string(j));
        }

        let obj = j.t_object!;

        let obj_frames = obj.("frames");
        if obj_frames.t_object == nil {
            panic("Expected object, got {}", derive::to_string(obj_frames));
        }

        let obj_frames_obj = obj_frames.t_object!;

        let frames = make[map[string, Cell]]();

        for key in obj_frames_obj.list_keys() {
            let value = obj_frames_obj.(key);
            let cell = Cell::from_json(value);
            frames.(key) = cell;
        }

        return Sheet {
            frames: frames,
        };
    }
}

struct Cell {
    frame: Rect,
}

module Cell {
    fun from_json(j: Json): Cell {
        if j.t_object == nil {
            panic("Expected object, got {}", derive::to_string(j));
        }

        let obj = j.t_object!;

        let obj_frame = obj.("frame");
        let frame or err = Rect::from_json(obj_frame);
        if err != nil {
            panic("Failed to parse frame: {}", derive::to_string(err));
        }

        return Cell {
            frame: frame!,
        };
    }
}

struct Rect {
    x: i32,
    y: i32,
    w: i32,
    h: i32,
}

module Rect {
    fun from_json(j: Json): Rect or error {
        if j.t_object == nil {
            return _ or error::new("Expected object, got {}".format(derive::to_string(j)));
        }

        let obj = j.t_object!;

        let obj_x = obj.("x");
        if obj_x.t_i32 == nil {
            return _ or error::new("Expected number, got {}".format(derive::to_string(obj_x)));
        }

        let obj_y = obj.("y");
        if obj_y.t_i32 == nil {
            return _ or error::new("Expected number, got {}".format(derive::to_string(obj_y)));
        }

        let obj_w = obj.("w");
        if obj_w.t_i32 == nil {
            return _ or error::new("Expected number, got {}".format(derive::to_string(obj_w)));
        }

        let obj_h = obj.("h");
        if obj_h.t_i32 == nil {
            return _ or error::new("Expected number, got {}".format(derive::to_string(obj_h)));
        }

        return Rect {
            x: obj_x.t_i32!,
            y: obj_y.t_i32!,
            w: obj_w.t_i32!,
            h: obj_h.t_i32!,
        };
    }
}

@[ffi_export("call_closure")]
fun call_closure(callback: fun[(), nil]) {
    callback();
}

